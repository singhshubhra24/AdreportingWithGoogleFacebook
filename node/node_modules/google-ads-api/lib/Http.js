"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = __importDefault(require("request"));
const lodash_1 = require("lodash");
const bluebird_retry_1 = __importDefault(require("bluebird-retry"));
const token_1 = require("./token");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const parser_1 = __importDefault(require("./parser"));
const Error_1 = __importDefault(require("./Error"));
// const log = (obj: any) => {
//     console.log(require('util').inspect(obj, false, null))
// }
class Http {
    constructor({ async_account_getter, client_id, developer_token, client_secret, throttler, pre_query_hook, post_query_hook, }) {
        const account_promise = async_account_getter().then((account_info) => {
            const { cid, manager_cid, refresh_token } = account_info;
            if (lodash_1.isUndefined(cid) || lodash_1.isUndefined(refresh_token)) {
                throw new Error('Missing required customer ID or refresh token');
            }
            this.client.refresh_token = refresh_token;
            this.client.cid = cid
                .toString()
                .split('-')
                .join('');
            this.client.manager_cid = (manager_cid || '')
                .toString()
                .split('-')
                .join('');
        });
        this.throttler = throttler;
        this.pre_query_hook = pre_query_hook;
        this.post_query_hook = post_query_hook;
        this.client = {
            account_promise,
            cid: '',
            manager_cid: '',
            refresh_token: '',
            client_id,
            developer_token,
            client_secret,
        };
    }
    /*
     *   PUBLIC METHODS
     */
    create(config, entity) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.account_promise;
            const url = this.getRequestUrl('mutate', entity);
            const options = yield this.getRequestOptions('POST', url);
            if (Array.isArray(config)) {
                const operations = config.map(operation => ({ create: this.formatRequestConfig(operation, entity) }));
                options.body = JSON.stringify({ operations });
            }
            else {
                config = this.formatRequestConfig(config, entity);
                const create_operation = { create: config };
                options.body = JSON.stringify({ operations: [create_operation] });
            }
            return this.queryApi(options).then(response => {
                return utils_1.mapResultsWithIds(response);
            });
        });
    }
    retrieve(entity, entity_id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.account_promise;
            const url = this.getRequestUrl('get', entity, entity_id);
            const options = yield this.getRequestOptions('GET', url);
            return this.queryApi(options);
        });
    }
    list(config, resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const report_config = utils_1.buildListReportConfig(config, resource);
            return this.report(report_config);
        });
    }
    report(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { query, custom_metrics } = utils_1.buildReportQuery(config);
            yield this.client.account_promise; // need this to ensure that client.cid is set
            const pre_query_hook_result = yield this.pre_query_hook({
                cid: this.client.cid,
                query,
                report_config: config,
            });
            if (pre_query_hook_result) {
                return pre_query_hook_result;
            }
            const raw_result = yield this.query(query);
            const result = yield utils_1.formatQueryResults(raw_result, config.entity, lodash_1.isUndefined(config.convert_micros) ? true : config.convert_micros, custom_metrics);
            const parsed_result = parser_1.default.parseResult(result);
            const modified_result = yield this.post_query_hook({
                cid: this.client.cid,
                query,
                report_config: config,
                result: parsed_result,
            });
            /*
                The user may or may not actually return a modified result.
                If they don't, just return the original result.
            */
            return modified_result || parsed_result;
        });
    }
    update(config, entity) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.account_promise;
            const url = this.getRequestUrl('mutate', entity);
            const options = yield this.getRequestOptions('POST', url);
            if (Array.isArray(config)) {
                const operations = config.map(operation => {
                    const update_operation = {
                        update: operation.update,
                        update_mask: utils_1.getUpdateMask(operation.update),
                    };
                    update_operation.update.resource_name = this.buildResourceName(entity, operation.id);
                    return update_operation;
                });
                options.body = JSON.stringify({ operations });
            }
            else {
                const update_operation = {
                    update: config.update,
                    update_mask: utils_1.getUpdateMask(config.update),
                };
                update_operation.update.resource_name = this.buildResourceName(entity, config.id);
                options.body = JSON.stringify({ operations: [update_operation] });
            }
            return this.queryApi(options).then(response => {
                return utils_1.mapResultsWithIds(response);
            });
        });
    }
    delete(entity, entity_id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.account_promise;
            const url = this.getRequestUrl('mutate', entity);
            const options = yield this.getRequestOptions('POST', url);
            const update_operation = {
                remove: this.buildResourceName(entity, entity_id),
            };
            options.body = JSON.stringify({ operations: [update_operation] });
            return this.queryApi(options);
        });
    }
    query(query, page_size = 10000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.account_promise;
            const url = this.getRequestUrl();
            const options = yield this.getRequestOptions('POST', url);
            query = query.replace(/\s/g, ' ');
            options.qs = { query, page_size };
            const raw_result = yield this.queryApi(options);
            return raw_result;
        });
    }
    /*
     *   PRIVATE METHODS
     */
    queryApi(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { method, url, qs } = options;
            if (method === 'GET' ||
                url.includes('mutate') ||
                (qs && qs.query && qs.query.toLowerCase().includes('limit'))) {
                const response = yield this.queryWithRetry(options);
                /*
                    Sometimes the API returns no `results` field in the response when
                    there are no results. In that case, all it returns is the `fieldMask`.
                */
                if (lodash_1.keys(response).length === 1 && lodash_1.keys(response)[0] === 'fieldMask') {
                    return [];
                }
                return response.results ? lodash_1.values(utils_1.transformObjectKeys(response.results)) : utils_1.transformObjectKeys(response);
            }
            return this.queryIterator(options);
        });
    }
    queryIterator(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let query_results = [];
            let page = 0;
            let num_results = 0;
            let max_results = 0;
            let next_page_token = '';
            const hasNextPage = () => {
                if (page === 0) {
                    return true;
                }
                if (num_results >= max_results) {
                    return false;
                }
                return true;
            };
            const getNextPage = () => __awaiter(this, void 0, void 0, function* () {
                if (options.qs && next_page_token && next_page_token.length > 0) {
                    options.qs.page_token = next_page_token;
                }
                const data = yield this.queryWithRetry(options);
                const { totalResultsCount, nextPageToken, results } = data;
                page += 1;
                if (max_results === 0 && totalResultsCount) {
                    max_results = totalResultsCount;
                }
                if (nextPageToken) {
                    next_page_token = nextPageToken;
                }
                if (results && results.length > 0) {
                    num_results += results.length;
                    return lodash_1.values(utils_1.transformObjectKeys(results));
                }
                return [];
            });
            while (hasNextPage()) {
                const page_data = yield getNextPage();
                query_results = query_results.concat(page_data);
            }
            return parser_1.default.parseResult(query_results);
        });
    }
    queryWithRetry(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const work = () => __awaiter(this, void 0, void 0, function* () {
                const { response, body } = yield this.throttler.wrap(this.doHttpRequest).withOptions({
                    expiration: 1000 * 60,
                }, options);
                if (response.statusCode === 404) {
                    const { url } = options;
                    throw new bluebird_retry_1.default.StopError(new Error(`The requested URL ${url} was not found (404).`));
                }
                let decoded_body;
                try {
                    decoded_body = JSON.parse(body);
                }
                catch (_a) {
                    throw new bluebird_retry_1.default.StopError(new Error(`Could not decode JSON body: ${body}`));
                }
                if (response.statusCode === 200) {
                    return decoded_body;
                }
                // if the error is in the 400 range, it's our fault, so no need to retry.
                if (response.statusCode.toString()[0] === '4') {
                    if (lodash_1.get(decoded_body, 'error.details[0].errors[0].errorCode.databaseError') ===
                        'CONCURRENT_MODIFICATION') {
                        throw new Error_1.default(decoded_body.error);
                    }
                    throw new bluebird_retry_1.default.StopError(new Error_1.default(decoded_body.error));
                }
                // Errors that make it here will be retried.
                throw new Error_1.default(decoded_body.error);
            });
            return bluebird_retry_1.default(work, {
                max_tries: 3,
                interval: 1000 + lodash_1.random(1000),
                throw_original: true,
                backoff: 2,
            });
        });
    }
    doHttpRequest(options) {
        return new Promise((resolve, reject) => {
            request_1.default(options, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve({ response, body });
                }
            });
        });
    }
    getRequestOptions(method, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const access_token = yield token_1.getAccessToken(this.client);
            const headers = {
                'Content-Type': 'application/json',
                authorization: `Bearer ${access_token}`,
                'developer-token': this.client.developer_token,
            };
            if (this.client.manager_cid && this.client.manager_cid.length > 0) {
                headers['login-customer-id'] = this.client.manager_cid;
            }
            const options = {
                method,
                url,
                headers,
            };
            return options;
        });
    }
    formatRequestConfig(config, entity) {
        if (entity.includes('campaigns')) {
            config.campaign_budget = `customers/${this.client.cid}/campaignBudgets/${config.budget_id}`;
            delete config.budget_id;
        }
        else if (entity.includes('adGroups') || entity.includes('campaignCriteria')) {
            config.campaign = `customers/${this.client.cid}/campaigns/${config.campaign_id}`;
            delete config.campaign_id;
        }
        else if (entity.includes('adGroupAds') || entity.includes('adGroupCriteria')) {
            config.ad_group = `customers/${this.client.cid}/adGroups/${config.ad_group_id}`;
            delete config.ad_group_id;
        }
        else if (entity.includes('campaignSharedSets')) {
            config.campaign = `customers/${this.client.cid}/campaigns/${config.campaign_id}`;
            config.shared_set = `customers/${this.client.cid}/sharedSets/${config.shared_set_id}`;
            delete config.campaign_id;
            delete config.shared_set_id;
        }
        else if (entity.includes('sharedCriteria')) {
            config.shared_set = `customers/${this.client.cid}/sharedSets/${config.shared_set_id}`;
            delete config.shared_set_id;
        }
        return config;
    }
    getRequestUrl(operation_type, endpoint, entity_id) {
        if (endpoint && endpoint.includes('customers')) {
            return `${constants_1.ADWORDS_API_BASE_URL}${this.client.cid}`;
        }
        if (operation_type && operation_type.includes('get')) {
            return `${constants_1.ADWORDS_API_BASE_URL}${this.client.cid}/${endpoint}/${entity_id}`;
        }
        if (operation_type && operation_type.includes('mutate')) {
            return `${constants_1.ADWORDS_API_BASE_URL}${this.client.cid}/${endpoint}:mutate`;
        }
        return `${constants_1.ADWORDS_API_BASE_URL}${this.client.cid}/googleAds:search`;
    }
    buildResourceName(endpoint, entity_id) {
        return entity_id ? `customers/${this.client.cid}/${endpoint}/${entity_id}` : `customers/${this.client.cid}`;
    }
}
exports.default = Http;
