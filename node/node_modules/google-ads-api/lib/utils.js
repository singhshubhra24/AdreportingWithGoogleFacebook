"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const attributes_1 = __importDefault(require("./attributes"));
const metrics_1 = __importDefault(require("./metrics"));
const segments_1 = __importDefault(require("./segments"));
exports.getUpdateMask = (update_object) => {
    let mask = '';
    for (const key in update_object) {
        if (lodash_1.isObject(update_object[key])) {
            mask += Object.keys(update_object[key])
                .map(child_key => `${key}.${child_key}`)
                .join(',');
        }
        else {
            mask += `${key},`;
        }
    }
    return mask;
};
/**
 * Builds a custom Google Ads Query
 * @param {object} config
 * @returns {string} query
 */
exports.buildReportQuery = (config) => {
    let query = '';
    let where_clause_exists = false;
    const custom_metrics = [];
    /* SELECT Clause */
    config.attributes =
        config.attributes && config.attributes.length ? formatAttributes(config.attributes, config.entity) : [];
    config.segments = config.segments || [];
    config.metrics = config.metrics
        ? config.metrics.map((metric) => (metric.includes('metrics.') ? metric : `metrics.${metric}`))
        : [];
    config.constraints = config.constraints || [];
    // sort parts of query to encourage better caching
    config.attributes.sort();
    config.segments.sort();
    config.metrics.sort();
    const unrollConstraintShorthand = (constraint) => {
        if (!constraint.key) {
            const key = Object.keys(constraint)[0];
            const val = constraint[key];
            if (lodash_1.isArray(val)) {
                return { key, op: 'IN', val };
            }
            return { key, op: '=', val };
        }
        return constraint;
    };
    const addConstraintPrefix = (constraint) => {
        if (lodash_1.includes(lodash_1.map(metrics_1.default, 'name'), constraint.key)) {
            constraint.key = `metrics.${constraint.key}`;
        }
        else if (lodash_1.isUndefined(lodash_1.get(attributes_1.default, constraint.key))) {
            constraint.key = `${config.entity}.${constraint.key}`;
        }
        return constraint;
    };
    const getConstraintKeys = (constraint) => {
        if (lodash_1.isString(constraint)) {
            return false;
        }
        if (constraint.key) {
            return constraint.key;
        }
        return Object.keys(constraint)[0];
    };
    config.constraints = config.constraints.map((constraint) => {
        if (lodash_1.isString(constraint)) {
            return constraint;
        }
        const unrolled_constraint = unrollConstraintShorthand(constraint);
        const prefixed_constraint = addConstraintPrefix(unrolled_constraint);
        return prefixed_constraint;
    });
    const metrics_referenced_in_constraints = lodash_1.isArray(config.constraints)
        ? lodash_1.map(config.constraints, getConstraintKeys).filter((constraint_key) => lodash_1.includes(metrics_1.default.map(m => `metrics.${m.name}`), constraint_key))
        : [];
    const all_config_metrics = lodash_1.compact(lodash_1.uniq([...config.metrics, ...metrics_referenced_in_constraints]));
    all_config_metrics.forEach((config_metric) => {
        const matching_metric = lodash_1.find(metrics_1.default, {
            name: config_metric.replace('metrics.', ''),
        });
        if (matching_metric && matching_metric.pre_query_hook) {
            config = matching_metric.pre_query_hook(config);
        }
        if (matching_metric && matching_metric.is_custom) {
            custom_metrics.push(matching_metric);
        }
    });
    const all_selected_attributes = config.attributes
        .concat(config.metrics, config.segments.map(s => `segments.${s}`))
        .join(', ');
    if (!all_selected_attributes.length) {
        throw new Error('Missing attributes, metric fields or segments to be selected.');
    }
    query = `SELECT ${all_selected_attributes} FROM ${config.entity}`;
    /* WHERE Clause */
    /* Constraints */
    if (config.constraints && config.constraints.length) {
        const constraints = formatConstraints(config.constraints);
        query += ` WHERE ${constraints}`;
        where_clause_exists = true;
    }
    // TODO: add better error message
    if (config.date_constant && (config.from_date || config.to_date)) {
        throw new Error('Use only one, Custom date range or Predefined date range.');
    }
    if (config.from_date && !config.to_date) {
        const d = new Date();
        const today_string = `${d.getFullYear()}-${('0' + (d.getMonth() + 1)).slice(-2)}-${('0' + d.getDate()).slice(-2)}`;
        config.to_date = today_string;
    }
    else if (config.to_date && !config.from_date) {
        throw new Error('Expected start date range is missing. (from_date)');
    }
    /* Custom Date Range */
    if (config.from_date && config.to_date) {
        query += where_clause_exists ? ' AND ' : ' WHERE ';
        query += `segments.date >= '${config.from_date}' AND segments.date <= '${config.to_date}'`;
        where_clause_exists = true;
    }
    /* Predefined Date Constant */
    if (config.date_constant) {
        query += where_clause_exists ? ' AND ' : ' WHERE ';
        query += `segments.date DURING ${config.date_constant}`;
    }
    /* Order By */
    if (config.order_by) {
        query += formatOrderBy(config.entity, config.order_by, config.sort_order);
    }
    /* Limit To */
    if (config.limit && config.limit > 0) {
        query += ` LIMIT ${config.limit}`;
    }
    return { query, custom_metrics };
};
const formatAttributes = (attributes, entity) => {
    return attributes.map((attribute) => {
        if (lodash_1.isUndefined(lodash_1.get(attributes_1.default, attribute))) {
            return `${entity}.${attribute}`;
        }
        return attribute;
    });
};
const formatConstraints = (constraints) => {
    const formatConstraint = (constraint) => {
        if (lodash_1.isString(constraint)) {
            return constraint;
        }
        let key;
        let val;
        let op;
        if (lodash_1.isUndefined(constraint.key) || lodash_1.isUndefined(constraint.op) || lodash_1.isUndefined(constraint.val)) {
            throw new Error('must specify { key, op, val } when using object-style constraints');
        }
        key = constraint.key;
        op = constraint.op;
        val = constraint.val;
        if (lodash_1.isArray(constraint.val)) {
            if (constraint.val.length === 0) {
                val = `()`;
            }
            else {
                val = `("${constraint.val.sort().join(`","`)}")`;
            }
        }
        if (segments_1.default.map(s => s.name).includes(key)) {
            key = `segments.${key}`;
        }
        return `${key} ${op} ${val}`;
    };
    if (constraints instanceof Array) {
        return constraints
            .map(formatConstraint)
            .sort()
            .join(' AND ');
    }
    return constraints;
};
const formatOrderBy = (entity, order_by, sort_order) => {
    if (!sort_order) {
        // If sort order is unspecified, all values are sorted in DESCending order.
        sort_order = 'DESC';
    }
    if (order_by instanceof Array) {
        order_by = order_by.map((key) => (!key.includes('.') ? `${entity}.${key}` : key)).join(', ');
    }
    else {
        order_by = !order_by.includes('.') ? `${entity}.${order_by}` : order_by;
    }
    return ` ORDER BY ${order_by} ${sort_order}`;
};
exports.formatQueryResults = (result, entity, convert_micros, custom_metrics) => {
    return result.map((row) => {
        // removing main entity key from final object
        if (row[entity]) {
            lodash_1.merge(row, row[entity]);
            delete row[entity];
        }
        custom_metrics.forEach(custom_metric => {
            if (custom_metric.post_query_hook) {
                row = custom_metric.post_query_hook(row);
            }
        });
        return formatSingleResult(row, convert_micros);
    });
};
const formatSingleResult = (result_object, convert_micros) => {
    for (const key in result_object) {
        if (lodash_1.isObject(result_object[key])) {
            result_object[key] = formatSingleResult(result_object[key], convert_micros);
            continue;
        }
        const matching_metric = lodash_1.find(metrics_1.default, { name: key });
        if (convert_micros && matching_metric && matching_metric.is_micros) {
            result_object[key.split('_micros')[0]] = +result_object[key] / 1000000;
        }
        else if (convert_micros && key.includes('_micros')) {
            result_object[key.split('_micros')[0]] = +result_object[key] / 1000000;
        }
        if (matching_metric && matching_metric.is_number) {
            result_object[key] = +result_object[key];
        }
        if (isNumeric(result_object[key]) && !(key === 'id' || key.includes('.id'))) {
            result_object[key] = +result_object[key];
        }
    }
    return result_object;
};
const getAttributesList = (resource) => {
    const entity = attributes_1.default[resource];
    return mapAttributeObject(entity, resource);
};
const mapAttributeObject = (entity, prefix) => {
    return lodash_1.flattenDeep(Object.keys(entity).map(key => {
        if (lodash_1.isObject(entity[key])) {
            return mapAttributeObject(entity[key], `${prefix}.${key}`);
        }
        return `${prefix}.${key}`;
    }));
};
exports.buildListReportConfig = (config, resource) => {
    const attributes_list = getAttributesList(resource);
    if (!config) {
        return {
            entity: resource,
            attributes: attributes_list,
        };
    }
    const report_config = config;
    report_config.entity = resource;
    report_config.attributes = report_config.attributes || attributes_list;
    return report_config;
};
const mapSingleRowWithId = (row) => {
    const resource_name_split = row.resource_name ? row.resource_name.split('/') : null;
    if (resource_name_split) {
        return Object.assign({ id: resource_name_split[resource_name_split.length - 1] }, row);
    }
    return row;
};
const mapRowsWithId = (rows) => {
    return rows.map((row) => mapSingleRowWithId(row));
};
exports.mapResultsWithIds = (data) => {
    let result_rows;
    if (data.results && Array.isArray(data.results)) {
        result_rows = mapRowsWithId(data.results);
    }
    else if (Array.isArray(data)) {
        result_rows = mapRowsWithId(data);
    }
    else {
        return mapSingleRowWithId(data);
    }
    if (result_rows.length === 1) {
        return result_rows[0];
    }
    return result_rows;
};
exports.transformObjectKeys = (entity_object) => {
    const final = {};
    for (const key in entity_object) {
        if (lodash_1.isObject(entity_object[key])) {
            final[lodash_1.snakeCase(key)] = exports.transformObjectKeys(entity_object[key]);
        }
        else {
            final[lodash_1.snakeCase(key)] = entity_object[key];
        }
    }
    return final;
};
const isNumeric = (value) => {
    if (typeof value === 'boolean') {
        return false;
    }
    return !isNaN(value);
};
